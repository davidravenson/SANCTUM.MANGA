<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SANCTUM — Pilot</title>

  <style>
    :root{ --paper-bg: url("./media/ui/manga_paper_bg.png"); }

    html, body{
      margin:0; padding:0; height:100%;
      background:#000; color:#fff;
      font-family:system-ui,sans-serif;
      touch-action:auto;
    }

    body::before{
      content:"";
      position:fixed; inset:0; z-index:-1;
      background-image: var(--paper-bg);
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
    }

    .wrap{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:14px;
      padding:12px;
      box-sizing:border-box;
    }

    .panel{
      width:100%;
      max-width:900px;
      position:relative;
      overflow:hidden;
      background:rgba(0,0,0,0.18);
    }

    .panel img{
      width:100%;
      display:block;
      background:#000;
    }

    .hud{
      position:absolute;
      left:12px;
      bottom:12px;
      font-size:12px;
      opacity:0;
      background:rgba(0,0,0,0.55);
      padding:7px 10px;
      border-radius:10px;
      transition:opacity 180ms ease;
      pointer-events:none;
      max-width: calc(100% - 24px);
      white-space:pre-line;
    }
    .hud.visible{ opacity:0.92; }

    .toolbar{
      width:100%;
      max-width:900px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      border-radius:16px;
      background:rgba(10,10,10,0.55);
      border:1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
    }

    .trackName{
      flex:1;
      font-size:13px;
      line-height:1.25;
      white-space:pre-line;
      opacity:0.95;
      overflow:hidden;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
    }

    /* Volume + Play ring */
    .ringWrap{
      width:72px; height:72px;
      position:relative;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none; /* important: ring drag shouldn't scroll */
    }

    .ring{
      position:absolute; inset:0;
      border-radius:50%;
      background:conic-gradient(#fff 0deg, rgba(255,255,255,0.14) 0deg);
      -webkit-mask: radial-gradient(circle, transparent 60%, #000 61%);
              mask: radial-gradient(circle, transparent 60%, #000 61%);
      pointer-events:none;
    }

    .centerBtn{
      width:46px; height:46px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(20,20,20,0.95);
      display:grid;
      place-items:center;
      cursor:pointer;
      padding:0;
    }

    .centerBtn svg{ width:20px; height:20px; fill:#fff; display:block; }
  </style>
</head>

<body>

<audio id="bg-audio" preload="auto" playsinline></audio>

<div class="wrap">

  <div class="panel" id="panelArea">
    <img id="panelImg" src="" alt="SANCTUM Panel">
    <div class="hud" id="hud">Loading…</div>
  </div>

  <div class="toolbar">
    <div class="trackName" id="trackName"></div>

    <div class="ringWrap" id="ringWrap" aria-label="Volume ring with Play/Pause">
      <div class="ring" id="ring" aria-hidden="true"></div>
      <button class="centerBtn" id="centerBtn" aria-label="Play/Pause"></button>
    </div>
  </div>

</div>

<script>
  // =======================
  // CONFIG
  // =======================
  const CHAPTER = 0;
  const TOTAL_PANELS = 20;

  // Bump if you replaced the mp3 and cache is annoying
  const AUDIO_VERSION = 4;

  // First try SAME-ORIGIN (GitHub Pages), then RAW fallback
  const AUDIO_URL_PAGES = "./media/audio/chapter-00/instrumental.mp3";
  const AUDIO_URL_RAW =
    "https://raw.githubusercontent.com/davidravenson/SANCTUM.MANGA/master/media/audio/chapter-00/instrumental.mp3";

  const TRACK_TITLE  = "Arcangel (Placeholder)";
  const TRACK_ARTIST = "— (Artist later)";

  // =======================
  // ELEMENTS
  // =======================
  const audio = document.getElementById("bg-audio");
  const panelImg = document.getElementById("panelImg");
  const panelArea = document.getElementById("panelArea");
  const hud = document.getElementById("hud");

  const ringWrap = document.getElementById("ringWrap");
  const ring = document.getElementById("ring");
  const centerBtn = document.getElementById("centerBtn");
  const trackNameEl = document.getElementById("trackName");

  // Ensure not muted
  audio.muted = false;
  audio.setAttribute("playsinline", "");

  // =======================
  // HUD helper
  // =======================
  let hudTimer=null;
  function showHud(msg, ms=2000){
    if (msg !== undefined) hud.textContent = msg;
    hud.classList.add("visible");
    if (hudTimer) clearTimeout(hudTimer);
    hudTimer = setTimeout(()=>hud.classList.remove("visible"), ms);
  }

  // =======================
  // ICONS
  // =======================
  const ICON_PLAY = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M8 6.8v10.4c0 .9 1 1.4 1.7.9l9-5.2c.7-.4.7-1.4 0-1.8l-9-5.2C9 5.4 8 5.9 8 6.8Z"/>
    </svg>`;
  const ICON_PAUSE = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M8 6h3v12H8zM13 6h3v12h-3z"/>
    </svg>`;

  function updateIcon(){
    centerBtn.innerHTML = audio.paused ? ICON_PLAY : ICON_PAUSE;
  }

  // =======================
  // AUDIO SOURCE + START (needs user gesture)
  // =======================
  let usingRaw = false;
  let audioUnlocked = false;
  let attempting = false;

  function setAudioSrc(url){
    audio.src = `${url}?v=${AUDIO_VERSION}`;
    audio.load();
  }

  function setupAudio(){
    trackNameEl.textContent = `${TRACK_TITLE}\n${TRACK_ARTIST}`;
    setVolume(0.45);
    updateIcon();

    usingRaw = false;
    setAudioSrc(AUDIO_URL_PAGES);
  }

  async function playWithFadeIn(durationMs=2500){
    if (attempting) return false;
    attempting = true;

    const target = Math.max(0, Math.min(1, audio.volume || 0.45));
    audio.volume = 0;

    try{
      await audio.play();
      audioUnlocked = true;
      updateIcon();

      const steps = 45;
      let step = 0;
      const it = setInterval(()=>{
        step++;
        audio.volume = Math.min(target, (step/steps)*target);
        if (step >= steps) clearInterval(it);
      }, durationMs/steps);

      return true;
    }catch(e){
      // try RAW once if PAGES source fails
      if (!usingRaw){
        usingRaw = true;
        setAudioSrc(AUDIO_URL_RAW);
        try{
          await audio.play();
          audioUnlocked = true;
          updateIcon();
          showHud("Audio source fallback: RAW ✅", 1200);

          const steps = 45;
          let step = 0;
          const it = setInterval(()=>{
            step++;
            audio.volume = Math.min(target, (step/steps)*target);
            if (step >= steps) clearInterval(it);
          }, durationMs/steps);

          return true;
        }catch(e2){
          // Autoplay policy / still blocked
          audio.volume = target;
          updateIcon();
          showHud("Tap Play or Panel once to start audio.", 2200);
          return false;
        }
      }else{
        audio.volume = target;
        updateIcon();
        showHud("Tap Play or Panel once to start audio.", 2200);
        return false;
      }
    }finally{
      attempting = false;
    }
  }

  function audioDebugLine(){
    // readyState: 0..4  | networkState: 0..3
    return `readyState=${audio.readyState} network=${audio.networkState} t=${audio.currentTime.toFixed(2)} vol=${audio.volume.toFixed(2)} muted=${audio.muted}`;
  }

  centerBtn.addEventListener("click", async ()=>{
    if (audio.paused) {
      const ok = await playWithFadeIn(2500);
      if (!ok) showHud("Audio blocked.\n" + audioDebugLine(), 2600);
    } else {
      audio.pause();
      updateIcon();
    }
  });

  audio.addEventListener("play", ()=>{ audioUnlocked = true; updateIcon(); });
  audio.addEventListener("pause", updateIcon);
  audio.addEventListener("error", ()=>{
    const err = audio.error ? `code=${audio.error.code}` : "unknown";
    showHud("Audio error ("+err+").\n" + audioDebugLine(), 3200);
  });
  audio.addEventListener("stalled", ()=> showHud("Audio stalled.\n" + audioDebugLine(), 2200));
  audio.addEventListener("waiting", ()=> showHud("Audio loading…\n" + audioDebugLine(), 1200));
  audio.addEventListener("playing", ()=> showHud("Audio playing ✅", 900));

  // =======================
  // VOLUME RING (smooth drag, no jumps)
  // =======================
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function setVolume(v){
    v = clamp(v, 0, 1);
    audio.volume = v;

    const deg = Math.round(360 * v);
    ring.style.background =
      `conic-gradient(#fff ${deg}deg, rgba(255,255,255,0.14) ${deg}deg)`;
  }

  // Wide interaction band: allow touch inside/outside ring thickness
  function pointerInWideBand(clientX, clientY){
    const rect = ringWrap.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    const r = Math.sqrt(dx*dx + dy*dy);

    const outer = rect.width/2;
    const inner = outer * 0.60;
    const thickness = outer - inner;

    const expandedInner = Math.max(0, inner - thickness);
    const expandedOuter = outer + thickness;

    return (r >= expandedInner && r <= expandedOuter);
  }

  function touchAngleDeg(clientX, clientY){
    const rect = ringWrap.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;

    let deg = Math.atan2(dy, dx) * (180/Math.PI);
    deg = deg + 90; // 0 at top
    if (deg > 180) deg -= 360;
    return deg; // -180..180
  }

  const ANGLE_MIN = -135;
  const ANGLE_MAX = 135;

  let dragging=false;
  let lastDeg=0;
  let currentAngle = ANGLE_MIN + (ANGLE_MAX-ANGLE_MIN) * (audio.volume || 0.45);

  function angleToVolume(angle){
    const a = clamp(angle, ANGLE_MIN, ANGLE_MAX);
    return (a - ANGLE_MIN) / (ANGLE_MAX - ANGLE_MIN);
  }

  function startRing(e){
    const p = e.touches ? e.touches[0] : e;

    // ignore if on center button
    const cb = centerBtn.getBoundingClientRect();
    if (p.clientX >= cb.left && p.clientX <= cb.right &&
        p.clientY >= cb.top  && p.clientY <= cb.bottom) return;

    if (!pointerInWideBand(p.clientX, p.clientY)) { dragging=false; return; }

    dragging=true;
    lastDeg = touchAngleDeg(p.clientX, p.clientY);

    currentAngle = ANGLE_MIN + (ANGLE_MAX-ANGLE_MIN) * audio.volume;
    currentAngle = clamp(currentAngle, ANGLE_MIN, ANGLE_MAX);
  }

  function moveRing(e){
    if (!dragging) return;
    const p = e.touches ? e.touches[0] : e;

    if (!pointerInWideBand(p.clientX, p.clientY)) { dragging=false; return; }

    const now = touchAngleDeg(p.clientX, p.clientY);
    let delta = now - lastDeg;

    // unwrap seam
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;

    // cap glitches (no wild jumps)
    delta = clamp(delta, -25, 25);

    currentAngle = clamp(currentAngle + delta, ANGLE_MIN, ANGLE_MAX);
    setVolume(angleToVolume(currentAngle));

    lastDeg = now;
  }

  function endRing(){ dragging=false; }

  ringWrap.addEventListener("mousedown", startRing);
  window.addEventListener("mousemove", moveRing);
  window.addEventListener("mouseup", endRing);

  ringWrap.addEventListener("touchstart", startRing, {passive:true});
  window.addEventListener("touchmove", moveRing, {passive:true});
  window.addEventListener("touchend", endRing, {passive:true});

  // =======================
  // PANELS
  // manga/chapter-00/panel01.jpg
  // =======================
  let panelIndex = 1;
  const chapterFolder = `./manga/chapter-${String(CHAPTER).padStart(2,"0")}/`;
  const panelFile = i => `${chapterFolder}panel${String(i).padStart(2,"0")}.jpg`;

  function renderPanel(){
    panelImg.src = panelFile(panelIndex);
    showHud(`Panel ${panelIndex} / ${TOTAL_PANELS}`, 1200);
  }

  panelImg.onerror = ()=>{
    showHud(`Panel not found:\n${panelFile(panelIndex)}`, 3500);
  };

  // =======================
  // SWIPE (RIGHT = CONTINUE)
  // + first gesture unlocks audio
  // =======================
  let isPinching=false;
  let sx=0, sy=0, t0=0;

  async function unlockOnGesture(){
    if (audioUnlocked) return;
    const ok = await playWithFadeIn(2500);
    if (!ok) showHud("Tap Play to start audio.\n" + audioDebugLine(), 2600);
  }

  panelArea.addEventListener("touchstart", (e)=>{
    if (e.touches.length >= 2){ isPinching=true; return; }
    isPinching=false;

    const t = e.touches[0];
    sx=t.clientX; sy=t.clientY; t0=Date.now();

    showHud(`Panel ${panelIndex} / ${TOTAL_PANELS}`, 2000);
    unlockOnGesture();
  }, {passive:true});

  panelArea.addEventListener("touchmove", (e)=>{
    if (e.touches.length >= 2) isPinching=true;
  }, {passive:true});

  panelArea.addEventListener("touchend", (e)=>{
    if (isPinching) return;

    const t = e.changedTouches[0];
    const dx=t.clientX-sx;
    const dy=t.clientY-sy;
    const dt=Date.now()-t0;

    if(Math.abs(dx)>40 && Math.abs(dx)>Math.abs(dy)*1.2 && dt<700){
      // RIGHT swipe = continue
      if(dx > 0 && panelIndex < TOTAL_PANELS) panelIndex++;
      // LEFT swipe = back
      if(dx < 0 && panelIndex > 1) panelIndex--;
      renderPanel();
    }
  }, {passive:true});

  panelArea.addEventListener("click", ()=>{
    showHud(`Panel ${panelIndex} / ${TOTAL_PANELS}`, 2000);
    unlockOnGesture();
  });

  // =======================
  // INIT
  // =======================
  window.addEventListener("load", ()=>{
    setupAudio();
    renderPanel();
    // Do NOT force play here — will be blocked. We wait for gesture.
    showHud("Tap Play or swipe once to start audio.", 1800);
  });
</script>

</body>
</html>